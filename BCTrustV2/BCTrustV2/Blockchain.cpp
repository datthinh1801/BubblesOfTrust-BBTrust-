/**********************************************************
*                                                         *
*	Copyright (C)  2017				  *
*	GNU GENERAL PUBLIC LICENSE Version 3              *
*                                                         *
*	Author name : Mohamed Tahar HAMMI                 *
*	Date        : 01/June/2017                        *
*	Contact     : hammi_mohamed_tahar@hotmail.fr      *
*                                                         *
**********************************************************/


#include "Blockchain.h"

#define CONTRACT_PATH "/home/ubuntu/BubblesOfTrust-BBTrust-/BCTrustV2/contracts/BCTrustV2.sol"
#define _32Bytes       64
#define _AddrTypeLen   (20 * 2)
#define _AddrPaddLen   _32Bytes - _AddrTypeLen




Blockchain::Blockchain(const QString& ipAddr, const QString& p) : ipAddress(ipAddr), port (p)/*, request(0), response (0)*/,
                                                                  coinbase(""), contractData(""), contractGasEstimate(""),
                                                                  transactionHash("")

#if 0
                                                                , myExternalAddress ("")
#endif
{
    client   = new HttpClient("http://" + ipAddress + ":" + port) ;

// 1) // Je pense qu'on a pas besoin de récupérer l'addresse du mineur (coinbase)

    coinbase = getCoinbaseFromTheBlockChain() ;
    if(coinbase.isEmpty()) {
        qDebug() << "Error:Blockchain::Blockchain, getCoinbaseFromTheBlockChain call failed" ;
        return ;
    }

// 2)
    QVariantList params ;
    params.append(FileToString (CONTRACT_PATH)) ;
    // I can use only 10 args as parameters ;
    /*
    request = QJsonRpcMessage::createRequest("eth_compileSolidity", QJsonArray::fromVariantList(params)) ;
    response = client->sendMessageBlocking(request) ;

    if (response.type() == QJsonRpcMessage::Error) {
        qDebug() << response.errorData() ;
        exit (0) ; // todo change it
    }

    QVariantMap resultObject = (QVariantMap) response.result().toObject().toVariantMap() ;
    contractData = (resultObject.take("code").toString()) ;
    */

    QVariantMap resultObject ;
    contractData = "PUSH1 0x60 PUSH1 0x40 MSTORE CALLVALUE ISZERO PUSH2 0xC JUMPI INVALID JUMPDEST JUMPDEST JUMPDEST JUMPDEST PUSH2 0x1690 DUP1 PUSH2 0x1E PUSH1 0x0 CODECOPY PUSH1 0x0 RETURN STOP PUSH1 0x60 PUSH1 0x40 MSTORE CALLDATASIZE ISZERO PUSH2 0xC3 JUMPI PUSH1 0x0 CALLDATALOAD PUSH29 0x100000000000000000000000000000000000000000000000000000000 SWAP1 DIV PUSH4 0xFFFFFFFF AND DUP1 PUSH4 0x116D00B1 EQ PUSH2 0xC5 JUMPI DUP1 PUSH4 0x1847C06B EQ PUSH2 0x137 JUMPI DUP1 PUSH4 0x89AFDA78 EQ PUSH2 0x1F4 JUMPI DUP1 PUSH4 0x90A3E05E EQ PUSH2 0x26A JUMPI DUP1 PUSH4 0x92F7338A EQ PUSH2 0x314 JUMPI DUP1 PUSH4 0xA0D7AC52 EQ PUSH2 0x361 JUMPI DUP1 PUSH4 0xA54EE5A5 EQ PUSH2 0x3C4 JUMPI DUP1 PUSH4 0xB90954C8 EQ PUSH2 0x46E JUMPI DUP1 PUSH4 0xD5290D8E EQ PUSH2 0x4D1 JUMPI DUP1 PUSH4 0xF0BED380 EQ PUSH2 0x587 JUMPI DUP1 PUSH4 0xF0D708B9 EQ PUSH2 0x644 JUMPI DUP1 PUSH4 0xF8A8FD6D EQ PUSH2 0x692 JUMPI DUP1 PUSH4 0xFB2A2638 EQ PUSH2 0x6BE JUMPI JUMPDEST INVALID JUMPDEST CALLVALUE ISZERO PUSH2 0xCD JUMPI INVALID JUMPDEST PUSH2 0x135 PUSH1 0x4 DUP1 DUP1 CALLDATALOAD PUSH1 0xFF AND SWAP1 PUSH1 0x20 ADD SWAP1 SWAP2 SWAP1 DUP1 CALLDATALOAD PUSH1 0xFF AND SWAP1 PUSH1 0x20 ADD SWAP1 SWAP2 SWAP1 DUP1 CALLDATALOAD SWAP1 PUSH1 0x20 ADD SWAP1 DUP3 ADD DUP1 CALLDATALOAD SWAP1 PUSH1 0x20 ADD SWAP1 DUP1 DUP1 PUSH1 0x1F ADD PUSH1 0x20 DUP1 SWAP2 DIV MUL PUSH1 0x20 ADD PUSH1 0x40 MLOAD SWAP1 DUP2 ADD PUSH1 0x40 MSTORE DUP1 SWAP4 SWAP3 SWAP2 SWAP1 DUP2 DUP2 MSTORE PUSH1 0x20 ADD DUP4 DUP4 DUP1 DUP3 DUP5 CALLDATACOPY DUP3 ADD SWAP2 POP POP POP POP POP POP SWAP2 SWAP1 POP POP PUSH2 0x769 JUMP JUMPDEST STOP JUMPDEST CALLVALUE ISZERO PUSH2 0x13F JUMPI INVALID JUMPDEST PUSH2 0x16B PUSH1 0x4 DUP1 DUP1 CALLDATALOAD PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND SWAP1 PUSH1 0x20 ADD SWAP1 SWAP2 SWAP1 POP POP PUSH2 0xA01 JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 DUP1 PUSH1 0x20 ADD DUP3 DUP2 SUB DUP3 MSTORE DUP4 DUP2 DUP2 MLOAD DUP2 MSTORE PUSH1 0x20 ADD SWAP2 POP DUP1 MLOAD SWAP1 PUSH1 0x20 ADD SWAP1 DUP1 DUP4 DUP4 PUSH1 0x0 DUP4 EQ PUSH2 0x1BA JUMPI JUMPDEST DUP1 MLOAD DUP3 MSTORE PUSH1 0x20 DUP4 GT ISZERO PUSH2 0x1BA JUMPI PUSH1 0x20 DUP3 ADD SWAP2 POP PUSH1 0x20 DUP2 ADD SWAP1 POP PUSH1 0x20 DUP4 SUB SWAP3 POP PUSH2 0x196 JUMP JUMPDEST POP POP POP SWAP1 POP SWAP1 DUP2 ADD SWAP1 PUSH1 0x1F AND DUP1 ISZERO PUSH2 0x1E6 JUMPI DUP1 DUP3 SUB DUP1 MLOAD PUSH1 0x1 DUP4 PUSH1 0x20 SUB PUSH2 0x100 EXP SUB NOT AND DUP2 MSTORE PUSH1 0x20 ADD SWAP2 POP JUMPDEST POP SWAP3 POP POP POP PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST CALLVALUE ISZERO PUSH2 0x1FC JUMPI INVALID JUMPDEST PUSH2 0x24C PUSH1 0x4 DUP1 DUP1 CALLDATALOAD SWAP1 PUSH1 0x20 ADD SWAP1 DUP3 ADD DUP1 CALLDATALOAD SWAP1 PUSH1 0x20 ADD SWAP1 DUP1 DUP1 PUSH1 0x1F ADD PUSH1 0x20 DUP1 SWAP2 DIV MUL PUSH1 0x20 ADD PUSH1 0x40 MLOAD SWAP1 DUP2 ADD PUSH1 0x40 MSTORE DUP1 SWAP4 SWAP3 SWAP2 SWAP1 DUP2 DUP2 MSTORE PUSH1 0x20 ADD DUP4 DUP4 DUP1 DUP3 DUP5 CALLDATACOPY DUP3 ADD SWAP2 POP POP POP POP POP POP SWAP2 SWAP1 POP POP PUSH2 0xAB1 JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 DUP3 PUSH1 0x0 NOT AND PUSH1 0x0 NOT AND DUP2 MSTORE PUSH1 0x20 ADD SWAP2 POP POP PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST CALLVALUE ISZERO PUSH2 0x272 JUMPI INVALID JUMPDEST PUSH2 0x28B PUSH1 0x4 DUP1 DUP1 CALLDATALOAD PUSH1 0xFF AND SWAP1 PUSH1 0x20 ADD SWAP1 SWAP2 SWAP1 POP POP PUSH2 0xAC0 JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 DUP1 PUSH1 0x20 ADD DUP3 DUP2 SUB DUP3 MSTORE DUP4 DUP2 DUP2 MLOAD DUP2 MSTORE PUSH1 0x20 ADD SWAP2 POP DUP1 MLOAD SWAP1 PUSH1 0x20 ADD SWAP1 DUP1 DUP4 DUP4 PUSH1 0x0 DUP4 EQ PUSH2 0x2DA JUMPI JUMPDEST DUP1 MLOAD DUP3 MSTORE PUSH1 0x20 DUP4 GT ISZERO PUSH2 0x2DA JUMPI PUSH1 0x20 DUP3 ADD SWAP2 POP PUSH1 0x20 DUP2 ADD SWAP1 POP PUSH1 0x20 DUP4 SUB SWAP3 POP PUSH2 0x2B6 JUMP JUMPDEST POP POP POP SWAP1 POP SWAP1 DUP2 ADD SWAP1 PUSH1 0x1F AND DUP1 ISZERO PUSH2 0x306 JUMPI DUP1 DUP3 SUB DUP1 MLOAD PUSH1 0x1 DUP4 PUSH1 0x20 SUB PUSH2 0x100 EXP SUB NOT AND DUP2 MSTORE PUSH1 0x20 ADD SWAP2 POP JUMPDEST POP SWAP3 POP POP POP PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST CALLVALUE ISZERO PUSH2 0x31C JUMPI INVALID JUMPDEST PUSH2 0x35F PUSH1 0x4 DUP1 DUP1 CALLDATALOAD PUSH1 0xFF AND SWAP1 PUSH1 0x20 ADD SWAP1 SWAP2 SWAP1 DUP1 CALLDATALOAD PUSH1 0xFF AND SWAP1 PUSH1 0x20 ADD SWAP1 SWAP2 SWAP1 DUP1 CALLDATALOAD PUSH1 0xFF AND SWAP1 PUSH1 0x20 ADD SWAP1 SWAP2 SWAP1 DUP1 CALLDATALOAD SWAP1 PUSH1 0x20 ADD SWAP1 SWAP2 SWAP1 DUP1 CALLDATALOAD SWAP1 PUSH1 0x20 ADD SWAP1 SWAP2 SWAP1 POP POP PUSH2 0xB70 JUMP JUMPDEST STOP JUMPDEST CALLVALUE ISZERO PUSH2 0x369 JUMPI INVALID JUMPDEST PUSH2 0x382 PUSH1 0x4 DUP1 DUP1 CALLDATALOAD PUSH1 0xFF AND SWAP1 PUSH1 0x20 ADD SWAP1 SWAP2 SWAP1 POP POP PUSH2 0xDDA JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 DUP3 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 MSTORE PUSH1 0x20 ADD SWAP2 POP POP PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST CALLVALUE ISZERO PUSH2 0x3CC JUMPI INVALID JUMPDEST PUSH2 0x3E5 PUSH1 0x4 DUP1 DUP1 CALLDATALOAD PUSH1 0xFF AND SWAP1 PUSH1 0x20 ADD SWAP1 SWAP2 SWAP1 POP POP PUSH2 0xE0D JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 DUP1 PUSH1 0x20 ADD DUP3 DUP2 SUB DUP3 MSTORE DUP4 DUP2 DUP2 MLOAD DUP2 MSTORE PUSH1 0x20 ADD SWAP2 POP DUP1 MLOAD SWAP1 PUSH1 0x20 ADD SWAP1 DUP1 DUP4 DUP4 PUSH1 0x0 DUP4 EQ PUSH2 0x434 JUMPI JUMPDEST DUP1 MLOAD DUP3 MSTORE PUSH1 0x20 DUP4 GT ISZERO PUSH2 0x434 JUMPI PUSH1 0x20 DUP3 ADD SWAP2 POP PUSH1 0x20 DUP2 ADD SWAP1 POP PUSH1 0x20 DUP4 SUB SWAP3 POP PUSH2 0x410 JUMP JUMPDEST POP POP POP SWAP1 POP SWAP1 DUP2 ADD SWAP1 PUSH1 0x1F AND DUP1 ISZERO PUSH2 0x460 JUMPI DUP1 DUP3 SUB DUP1 MLOAD PUSH1 0x1 DUP4 PUSH1 0x20 SUB PUSH2 0x100 EXP SUB NOT AND DUP2 MSTORE PUSH1 0x20 ADD SWAP2 POP JUMPDEST POP SWAP3 POP POP POP PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST CALLVALUE ISZERO PUSH2 0x476 JUMPI INVALID JUMPDEST PUSH2 0x48F PUSH1 0x4 DUP1 DUP1 CALLDATALOAD PUSH1 0xFF AND SWAP1 PUSH1 0x20 ADD SWAP1 SWAP2 SWAP1 POP POP PUSH2 0xF46 JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 DUP3 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 MSTORE PUSH1 0x20 ADD SWAP2 POP POP PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST CALLVALUE ISZERO PUSH2 0x4D9 JUMPI INVALID JUMPDEST PUSH2 0x4FE PUSH1 0x4 DUP1 DUP1 CALLDATALOAD PUSH1 0xFF AND SWAP1 PUSH1 0x20 ADD SWAP1 SWAP2 SWAP1 DUP1 CALLDATALOAD PUSH1 0xFF AND SWAP1 PUSH1 0x20 ADD SWAP1 SWAP2 SWAP1 POP POP PUSH2 0xF79 JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 DUP1 PUSH1 0x20 ADD DUP3 DUP2 SUB DUP3 MSTORE DUP4 DUP2 DUP2 MLOAD DUP2 MSTORE PUSH1 0x20 ADD SWAP2 POP DUP1 MLOAD SWAP1 PUSH1 0x20 ADD SWAP1 DUP1 DUP4 DUP4 PUSH1 0x0 DUP4 EQ PUSH2 0x54D JUMPI JUMPDEST DUP1 MLOAD DUP3 MSTORE PUSH1 0x20 DUP4 GT ISZERO PUSH2 0x54D JUMPI PUSH1 0x20 DUP3 ADD SWAP2 POP PUSH1 0x20 DUP2 ADD SWAP1 POP PUSH1 0x20 DUP4 SUB SWAP3 POP PUSH2 0x529 JUMP JUMPDEST POP POP POP SWAP1 POP SWAP1 DUP2 ADD SWAP1 PUSH1 0x1F AND DUP1 ISZERO PUSH2 0x579 JUMPI DUP1 DUP3 SUB DUP1 MLOAD PUSH1 0x1 DUP4 PUSH1 0x20 SUB PUSH2 0x100 EXP SUB NOT AND DUP2 MSTORE PUSH1 0x20 ADD SWAP2 POP JUMPDEST POP SWAP3 POP POP POP PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST CALLVALUE ISZERO PUSH2 0x58F JUMPI INVALID JUMPDEST PUSH2 0x5BB PUSH1 0x4 DUP1 DUP1 CALLDATALOAD PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND SWAP1 PUSH1 0x20 ADD SWAP1 SWAP2 SWAP1 POP POP PUSH2 0x108C JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 DUP1 PUSH1 0x20 ADD DUP3 DUP2 SUB DUP3 MSTORE DUP4 DUP2 DUP2 MLOAD DUP2 MSTORE PUSH1 0x20 ADD SWAP2 POP DUP1 MLOAD SWAP1 PUSH1 0x20 ADD SWAP1 DUP1 DUP4 DUP4 PUSH1 0x0 DUP4 EQ PUSH2 0x60A JUMPI JUMPDEST DUP1 MLOAD DUP3 MSTORE PUSH1 0x20 DUP4 GT ISZERO PUSH2 0x60A JUMPI PUSH1 0x20 DUP3 ADD SWAP2 POP PUSH1 0x20 DUP2 ADD SWAP1 POP PUSH1 0x20 DUP4 SUB SWAP3 POP PUSH2 0x5E6 JUMP JUMPDEST POP POP POP SWAP1 POP SWAP1 DUP2 ADD SWAP1 PUSH1 0x1F AND DUP1 ISZERO PUSH2 0x636 JUMPI DUP1 DUP3 SUB DUP1 MLOAD PUSH1 0x1 DUP4 PUSH1 0x20 SUB PUSH2 0x100 EXP SUB NOT AND DUP2 MSTORE PUSH1 0x20 ADD SWAP2 POP JUMPDEST POP SWAP3 POP POP POP PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST CALLVALUE ISZERO PUSH2 0x64C JUMPI INVALID JUMPDEST PUSH2 0x690 PUSH1 0x4 DUP1 DUP1 CALLDATALOAD PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND SWAP1 PUSH1 0x20 ADD SWAP1 SWAP2 SWAP1 DUP1 CALLDATALOAD PUSH1 0xFF AND SWAP1 PUSH1 0x20 ADD SWAP1 SWAP2 SWAP1 DUP1 CALLDATALOAD PUSH1 0xFF AND SWAP1 PUSH1 0x20 ADD SWAP1 SWAP2 SWAP1 POP POP PUSH2 0x10C5 JUMP JUMPDEST STOP JUMPDEST CALLVALUE ISZERO PUSH2 0x69A JUMPI INVALID JUMPDEST PUSH2 0x6A2 PUSH2 0x1128 JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 DUP3 PUSH1 0xFF AND PUSH1 0xFF AND DUP2 MSTORE PUSH1 0x20 ADD SWAP2 POP POP PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST CALLVALUE ISZERO PUSH2 0x6C6 JUMPI INVALID JUMPDEST PUSH2 0x74F PUSH1 0x4 DUP1 DUP1 CALLDATALOAD SWAP1 PUSH1 0x20 ADD SWAP1 DUP3 ADD DUP1 CALLDATALOAD SWAP1 PUSH1 0x20 ADD SWAP1 DUP1 DUP1 PUSH1 0x1F ADD PUSH1 0x20 DUP1 SWAP2 DIV MUL PUSH1 0x20 ADD PUSH1 0x40 MLOAD SWAP1 DUP2 ADD PUSH1 0x40 MSTORE DUP1 SWAP4 SWAP3 SWAP2 SWAP1 DUP2 DUP2 MSTORE PUSH1 0x20 ADD DUP4 DUP4 DUP1 DUP3 DUP5 CALLDATACOPY DUP3 ADD SWAP2 POP POP POP POP POP POP SWAP2 SWAP1 DUP1 CALLDATALOAD PUSH1 0x0 NOT AND SWAP1 PUSH1 0x20 ADD SWAP1 SWAP2 SWAP1 DUP1 CALLDATALOAD PUSH1 0x0 NOT AND SWAP1 PUSH1 0x20 ADD SWAP1 SWAP2 SWAP1 DUP1 CALLDATALOAD PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND SWAP1 PUSH1 0x20 ADD SWAP1 SWAP2 SWAP1 POP POP PUSH2 0x1132 JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 DUP3 ISZERO ISZERO ISZERO ISZERO DUP2 MSTORE PUSH1 0x20 ADD SWAP2 POP POP PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST DUP3 DUP3 PUSH1 0x0 PUSH1 0x0 PUSH1 0x2 PUSH1 0x0 DUP6 PUSH1 0xFF AND PUSH1 0xFF AND DUP2 MSTORE PUSH1 0x20 ADD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD PUSH1 0x0 SHA3 PUSH1 0x0 SWAP1 SLOAD SWAP1 PUSH2 0x100 EXP SWAP1 DIV PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND SWAP2 POP PUSH1 0x2 PUSH1 0x0 DUP5 PUSH1 0xFF AND PUSH1 0xFF AND DUP2 MSTORE PUSH1 0x20 ADD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD PUSH1 0x0 SHA3 PUSH1 0x0 SWAP1 SLOAD SWAP1 PUSH2 0x100 EXP SWAP1 DIV PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND SWAP1 POP PUSH1 0x0 DUP3 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND EQ ISZERO PUSH2 0x80C JUMPI PUSH1 0x0 PUSH1 0x0 REVERT JUMPDEST PUSH1 0x0 DUP2 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND EQ ISZERO PUSH2 0x831 JUMPI PUSH1 0x0 PUSH1 0x0 REVERT JUMPDEST PUSH1 0x0 PUSH1 0x0 DUP3 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 MSTORE PUSH1 0x20 ADD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD PUSH1 0x0 SHA3 PUSH1 0x0 DUP2 SLOAD PUSH1 0x1 DUP2 PUSH1 0x1 AND ISZERO PUSH2 0x100 MUL SUB AND PUSH1 0x2 SWAP1 DIV DUP2 LT ISZERO ISZERO PUSH2 0x88F JUMPI INVALID JUMPDEST DUP2 SLOAD PUSH1 0x1 AND ISZERO PUSH2 0x8AE JUMPI SWAP1 PUSH1 0x0 MSTORE PUSH1 0x20 PUSH1 0x0 SHA3 SWAP1 PUSH1 0x20 SWAP2 DUP3 DUP3 DIV ADD SWAP2 SWAP1 MOD JUMPDEST SWAP1 SLOAD SWAP1 BYTE PUSH32 0x100000000000000000000000000000000000000000000000000000000000000 MUL PUSH31 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF NOT AND PUSH1 0x0 PUSH1 0x0 DUP5 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 MSTORE PUSH1 0x20 ADD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD PUSH1 0x0 SHA3 PUSH1 0x0 DUP2 SLOAD PUSH1 0x1 DUP2 PUSH1 0x1 AND ISZERO PUSH2 0x100 MUL SUB AND PUSH1 0x2 SWAP1 DIV DUP2 LT ISZERO ISZERO PUSH2 0x954 JUMPI INVALID JUMPDEST DUP2 SLOAD PUSH1 0x1 AND ISZERO PUSH2 0x973 JUMPI SWAP1 PUSH1 0x0 MSTORE PUSH1 0x20 PUSH1 0x0 SHA3 SWAP1 PUSH1 0x20 SWAP2 DUP3 DUP3 DIV ADD SWAP2 SWAP1 MOD JUMPDEST SWAP1 SLOAD SWAP1 BYTE PUSH32 0x100000000000000000000000000000000000000000000000000000000000000 MUL PUSH31 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF NOT AND EQ ISZERO ISZERO PUSH2 0x9C8 JUMPI PUSH1 0x0 PUSH1 0x0 REVERT JUMPDEST DUP5 PUSH1 0x3 PUSH1 0x0 DUP9 PUSH1 0xFF AND PUSH1 0xFF AND DUP2 MSTORE PUSH1 0x20 ADD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD PUSH1 0x0 SHA3 SWAP1 DUP1 MLOAD SWAP1 PUSH1 0x20 ADD SWAP1 PUSH2 0x9F5 SWAP3 SWAP2 SWAP1 PUSH2 0x1517 JUMP JUMPDEST POP JUMPDEST JUMPDEST POP POP POP POP POP POP POP JUMP JUMPDEST PUSH1 0x0 PUSH1 0x20 MSTORE DUP1 PUSH1 0x0 MSTORE PUSH1 0x40 PUSH1 0x0 SHA3 PUSH1 0x0 SWAP2 POP SWAP1 POP DUP1 SLOAD PUSH1 0x1 DUP2 PUSH1 0x1 AND ISZERO PUSH2 0x100 MUL SUB AND PUSH1 0x2 SWAP1 DIV DUP1 PUSH1 0x1F ADD PUSH1 0x20 DUP1 SWAP2 DIV MUL PUSH1 0x20 ADD PUSH1 0x40 MLOAD SWAP1 DUP2 ADD PUSH1 0x40 MSTORE DUP1 SWAP3 SWAP2 SWAP1 DUP2 DUP2 MSTORE PUSH1 0x20 ADD DUP3 DUP1 SLOAD PUSH1 0x1 DUP2 PUSH1 0x1 AND ISZERO PUSH2 0x100 MUL SUB AND PUSH1 0x2 SWAP1 DIV DUP1 ISZERO PUSH2 0xAA9 JUMPI DUP1 PUSH1 0x1F LT PUSH2 0xA7E JUMPI PUSH2 0x100 DUP1 DUP4 SLOAD DIV MUL DUP4 MSTORE SWAP2 PUSH1 0x20 ADD SWAP2 PUSH2 0xAA9 JUMP JUMPDEST DUP3 ADD SWAP2 SWAP1 PUSH1 0x0 MSTORE PUSH1 0x20 PUSH1 0x0 SHA3 SWAP1 JUMPDEST DUP2 SLOAD DUP2 MSTORE SWAP1 PUSH1 0x1 ADD SWAP1 PUSH1 0x20 ADD DUP1 DUP4 GT PUSH2 0xA8C JUMPI DUP3 SWAP1 SUB PUSH1 0x1F AND DUP3 ADD SWAP2 JUMPDEST POP POP POP POP POP DUP2 JUMP JUMPDEST PUSH1 0x0 PUSH1 0x20 DUP3 ADD MLOAD SWAP1 POP JUMPDEST SWAP2 SWAP1 POP JUMP JUMPDEST PUSH1 0x3 PUSH1 0x20 MSTORE DUP1 PUSH1 0x0 MSTORE PUSH1 0x40 PUSH1 0x0 SHA3 PUSH1 0x0 SWAP2 POP SWAP1 POP DUP1 SLOAD PUSH1 0x1 DUP2 PUSH1 0x1 AND ISZERO PUSH2 0x100 MUL SUB AND PUSH1 0x2 SWAP1 DIV DUP1 PUSH1 0x1F ADD PUSH1 0x20 DUP1 SWAP2 DIV MUL PUSH1 0x20 ADD PUSH1 0x40 MLOAD SWAP1 DUP2 ADD PUSH1 0x40 MSTORE DUP1 SWAP3 SWAP2 SWAP1 DUP2 DUP2 MSTORE PUSH1 0x20 ADD DUP3 DUP1 SLOAD PUSH1 0x1 DUP2 PUSH1 0x1 AND ISZERO PUSH2 0x100 MUL SUB AND PUSH1 0x2 SWAP1 DIV DUP1 ISZERO PUSH2 0xB68 JUMPI DUP1 PUSH1 0x1F LT PUSH2 0xB3D JUMPI PUSH2 0x100 DUP1 DUP4 SLOAD DIV MUL DUP4 MSTORE SWAP2 PUSH1 0x20 ADD SWAP2 PUSH2 0xB68 JUMP JUMPDEST DUP3 ADD SWAP2 SWAP1 PUSH1 0x0 MSTORE PUSH1 0x20 PUSH1 0x0 SHA3 SWAP1 JUMPDEST DUP2 SLOAD DUP2 MSTORE SWAP1 PUSH1 0x1 ADD SWAP1 PUSH1 0x20 ADD DUP1 DUP4 GT PUSH2 0xB4B JUMPI DUP3 SWAP1 SUB PUSH1 0x1F AND DUP3 ADD SWAP2 JUMPDEST POP POP POP POP POP DUP2 JUMP JUMPDEST PUSH2 0xB78 PUSH2 0x1597 JUMP JUMPDEST PUSH1 0x0 PUSH1 0x0 PUSH1 0x0 CALLER PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 MSTORE PUSH1 0x20 ADD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD PUSH1 0x0 SHA3 DUP1 SLOAD PUSH1 0x1 DUP2 PUSH1 0x1 AND ISZERO PUSH2 0x100 MUL SUB AND PUSH1 0x2 SWAP1 DIV SWAP1 POP EQ ISZERO ISZERO PUSH2 0xBDB JUMPI PUSH1 0x0 PUSH1 0x0 REVERT JUMPDEST PUSH1 0x0 PUSH1 0x2 PUSH1 0x0 DUP7 PUSH1 0xFF AND PUSH1 0xFF AND DUP2 MSTORE PUSH1 0x20 ADD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD PUSH1 0x0 SHA3 PUSH1 0x0 SWAP1 SLOAD SWAP1 PUSH2 0x100 EXP SWAP1 DIV PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND EQ ISZERO ISZERO PUSH2 0xC3A JUMPI PUSH1 0x0 PUSH1 0x0 REVERT JUMPDEST PUSH1 0x0 DUP7 PUSH1 0xFF AND EQ ISZERO PUSH2 0xD03 JUMPI PUSH1 0x0 PUSH1 0x1 PUSH1 0x0 DUP8 PUSH1 0xFF AND PUSH1 0xFF AND DUP2 MSTORE PUSH1 0x20 ADD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD PUSH1 0x0 SHA3 PUSH1 0x0 SWAP1 SLOAD SWAP1 PUSH2 0x100 EXP SWAP1 DIV PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND EQ ISZERO ISZERO PUSH2 0xCA5 JUMPI PUSH1 0x0 PUSH1 0x0 REVERT JUMPDEST CALLER PUSH1 0x1 PUSH1 0x0 DUP8 PUSH1 0xFF AND PUSH1 0xFF AND DUP2 MSTORE PUSH1 0x20 ADD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD PUSH1 0x0 SHA3 PUSH1 0x0 PUSH2 0x100 EXP DUP2 SLOAD DUP2 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF MUL NOT AND SWAP1 DUP4 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND MUL OR SWAP1 SSTORE POP JUMPDEST PUSH2 0xD6E JUMP JUMPDEST PUSH2 0xD0E DUP6 DUP6 CALLER PUSH2 0x132F JUMP JUMPDEST SWAP1 POP PUSH1 0x0 ISZERO ISZERO PUSH2 0xD5F DUP3 DUP6 PUSH1 0x1 MUL DUP6 PUSH1 0x1 MUL PUSH1 0x1 PUSH1 0x0 DUP12 PUSH1 0xFF AND PUSH1 0xFF AND DUP2 MSTORE PUSH1 0x20 ADD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD PUSH1 0x0 SHA3 PUSH1 0x0 SWAP1 SLOAD SWAP1 PUSH2 0x100 EXP SWAP1 DIV PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH2 0x1132 JUMP JUMPDEST ISZERO ISZERO EQ ISZERO PUSH2 0xD6D JUMPI PUSH1 0x0 PUSH1 0x0 REVERT JUMPDEST JUMPDEST CALLER PUSH1 0x2 PUSH1 0x0 DUP7 PUSH1 0xFF AND PUSH1 0xFF AND DUP2 MSTORE PUSH1 0x20 ADD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD PUSH1 0x0 SHA3 PUSH1 0x0 PUSH2 0x100 EXP DUP2 SLOAD DUP2 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF MUL NOT AND SWAP1 DUP4 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND MUL OR SWAP1 SSTORE POP PUSH2 0xDD1 CALLER DUP7 DUP7 PUSH2 0x10C5 JUMP JUMPDEST JUMPDEST POP POP POP POP POP POP JUMP JUMPDEST PUSH1 0x1 PUSH1 0x20 MSTORE DUP1 PUSH1 0x0 MSTORE PUSH1 0x40 PUSH1 0x0 SHA3 PUSH1 0x0 SWAP2 POP SLOAD SWAP1 PUSH2 0x100 EXP SWAP1 DIV PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 JUMP JUMPDEST PUSH2 0xE15 PUSH2 0x15AB JUMP JUMPDEST DUP2 CALLER PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH1 0x2 PUSH1 0x0 DUP4 PUSH1 0xFF AND PUSH1 0xFF AND DUP2 MSTORE PUSH1 0x20 ADD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD PUSH1 0x0 SHA3 PUSH1 0x0 SWAP1 SLOAD SWAP1 PUSH2 0x100 EXP SWAP1 DIV PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND EQ ISZERO ISZERO PUSH2 0xE8A JUMPI PUSH1 0x0 PUSH1 0x0 REVERT JUMPDEST PUSH1 0x3 PUSH1 0x0 DUP5 PUSH1 0xFF AND PUSH1 0xFF AND DUP2 MSTORE PUSH1 0x20 ADD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD PUSH1 0x0 SHA3 DUP1 SLOAD PUSH1 0x1 DUP2 PUSH1 0x1 AND ISZERO PUSH2 0x100 MUL SUB AND PUSH1 0x2 SWAP1 DIV DUP1 PUSH1 0x1F ADD PUSH1 0x20 DUP1 SWAP2 DIV MUL PUSH1 0x20 ADD PUSH1 0x40 MLOAD SWAP1 DUP2 ADD PUSH1 0x40 MSTORE DUP1 SWAP3 SWAP2 SWAP1 DUP2 DUP2 MSTORE PUSH1 0x20 ADD DUP3 DUP1 SLOAD PUSH1 0x1 DUP2 PUSH1 0x1 AND ISZERO PUSH2 0x100 MUL SUB AND PUSH1 0x2 SWAP1 DIV DUP1 ISZERO PUSH2 0xF37 JUMPI DUP1 PUSH1 0x1F LT PUSH2 0xF0C JUMPI PUSH2 0x100 DUP1 DUP4 SLOAD DIV MUL DUP4 MSTORE SWAP2 PUSH1 0x20 ADD SWAP2 PUSH2 0xF37 JUMP JUMPDEST DUP3 ADD SWAP2 SWAP1 PUSH1 0x0 MSTORE PUSH1 0x20 PUSH1 0x0 SHA3 SWAP1 JUMPDEST DUP2 SLOAD DUP2 MSTORE SWAP1 PUSH1 0x1 ADD SWAP1 PUSH1 0x20 ADD DUP1 DUP4 GT PUSH2 0xF1A JUMPI DUP3 SWAP1 SUB PUSH1 0x1F AND DUP3 ADD SWAP2 JUMPDEST POP POP POP POP POP SWAP2 POP JUMPDEST JUMPDEST POP SWAP2 SWAP1 POP JUMP JUMPDEST PUSH1 0x2 PUSH1 0x20 MSTORE DUP1 PUSH1 0x0 MSTORE PUSH1 0x40 PUSH1 0x0 SHA3 PUSH1 0x0 SWAP2 POP SLOAD SWAP1 PUSH2 0x100 EXP SWAP1 DIV PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 JUMP JUMPDEST PUSH2 0xF81 PUSH2 0x1597 JUMP JUMPDEST PUSH2 0xF89 PUSH2 0x1597 JUMP JUMPDEST PUSH1 0x0 PUSH1 0x2 PUSH1 0x40 MLOAD DUP1 MSIZE LT PUSH2 0xF9A JUMPI POP MSIZE JUMPDEST SWAP1 DUP1 DUP3 MSTORE DUP1 PUSH1 0x20 MUL PUSH1 0x20 ADD DUP3 ADD PUSH1 0x40 MSTORE JUMPDEST POP SWAP2 POP PUSH1 0x0 SWAP1 POP DUP5 PUSH32 0x100000000000000000000000000000000000000000000000000000000000000 MUL DUP3 DUP3 DUP1 PUSH1 0x1 ADD SWAP4 POP DUP2 MLOAD DUP2 LT ISZERO ISZERO PUSH2 0xFE9 JUMPI INVALID JUMPDEST SWAP1 PUSH1 0x20 ADD ADD SWAP1 PUSH31 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF NOT AND SWAP1 DUP2 PUSH1 0x0 BYTE SWAP1 MSTORE8 POP DUP4 PUSH32 0x100000000000000000000000000000000000000000000000000000000000000 MUL DUP3 DUP3 DUP1 PUSH1 0x1 ADD SWAP4 POP DUP2 MLOAD DUP2 LT ISZERO ISZERO PUSH2 0x1050 JUMPI INVALID JUMPDEST SWAP1 PUSH1 0x20 ADD ADD SWAP1 PUSH31 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF NOT AND SWAP1 DUP2 PUSH1 0x0 BYTE SWAP1 MSTORE8 POP DUP2 SWAP3 POP JUMPDEST POP POP SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH2 0x1094 PUSH2 0x1597 JUMP JUMPDEST PUSH1 0x40 MLOAD DUP3 PUSH21 0x140000000000000000000000000000000000000000 XOR PUSH1 0x14 DUP3 ADD MSTORE PUSH1 0x34 DUP2 ADD PUSH1 0x40 MSTORE DUP1 SWAP2 POP POP JUMPDEST SWAP2 SWAP1 POP JUMP JUMPDEST PUSH2 0x10CF DUP3 DUP3 PUSH2 0xF79 JUMP JUMPDEST PUSH1 0x0 PUSH1 0x0 DUP6 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 MSTORE PUSH1 0x20 ADD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD PUSH1 0x0 SHA3 SWAP1 DUP1 MLOAD SWAP1 PUSH1 0x20 ADD SWAP1 PUSH2 0x1121 SWAP3 SWAP2 SWAP1 PUSH2 0x15BF JUMP JUMPDEST POP JUMPDEST POP POP POP JUMP JUMPDEST PUSH1 0x0 PUSH1 0xA SWAP1 POP JUMPDEST SWAP1 JUMP JUMPDEST PUSH1 0x0 PUSH1 0x0 PUSH1 0x0 DUP7 PUSH1 0x40 MLOAD DUP1 DUP3 DUP1 MLOAD SWAP1 PUSH1 0x20 ADD SWAP1 DUP1 DUP4 DUP4 JUMPDEST PUSH1 0x20 DUP4 LT PUSH2 0x116C JUMPI DUP1 MLOAD DUP3 MSTORE PUSH1 0x20 DUP3 ADD SWAP2 POP PUSH1 0x20 DUP2 ADD SWAP1 POP PUSH1 0x20 DUP4 SUB SWAP3 POP PUSH2 0x1149 JUMP JUMPDEST PUSH1 0x1 DUP4 PUSH1 0x20 SUB PUSH2 0x100 EXP SUB DUP1 NOT DUP3 MLOAD AND DUP2 DUP5 MLOAD AND DUP1 DUP3 OR DUP6 MSTORE POP POP POP POP POP POP SWAP1 POP ADD SWAP2 POP POP PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 SHA3 SWAP2 POP PUSH1 0x1B SWAP1 POP DUP4 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH1 0x1 DUP4 DUP4 DUP10 DUP10 PUSH1 0x40 MLOAD DUP1 PUSH1 0x0 MSTORE PUSH1 0x20 ADD PUSH1 0x40 MSTORE PUSH1 0x0 PUSH1 0x40 MLOAD PUSH1 0x20 ADD MSTORE PUSH1 0x40 MLOAD DUP1 DUP6 PUSH1 0x0 NOT AND PUSH1 0x0 NOT AND DUP2 MSTORE PUSH1 0x20 ADD DUP5 PUSH1 0xFF AND PUSH1 0xFF AND DUP2 MSTORE PUSH1 0x20 ADD DUP4 PUSH1 0x0 NOT AND PUSH1 0x0 NOT AND DUP2 MSTORE PUSH1 0x20 ADD DUP3 PUSH1 0x0 NOT AND PUSH1 0x0 NOT AND DUP2 MSTORE PUSH1 0x20 ADD SWAP5 POP POP POP POP POP PUSH1 0x20 PUSH1 0x40 MLOAD PUSH1 0x20 DUP2 SUB SWAP1 DUP1 DUP5 SUB SWAP1 PUSH1 0x0 DUP7 PUSH2 0x61DA GAS SUB CALL ISZERO ISZERO PUSH2 0x1231 JUMPI INVALID JUMPDEST POP POP PUSH1 0x20 PUSH1 0x40 MLOAD SUB MLOAD PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND EQ DUP1 PUSH2 0x130D JUMPI POP DUP4 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH1 0x1 DUP4 PUSH1 0x1 DUP5 ADD DUP10 DUP10 PUSH1 0x40 MLOAD DUP1 PUSH1 0x0 MSTORE PUSH1 0x20 ADD PUSH1 0x40 MSTORE PUSH1 0x0 PUSH1 0x40 MLOAD PUSH1 0x20 ADD MSTORE PUSH1 0x40 MLOAD DUP1 DUP6 PUSH1 0x0 NOT AND PUSH1 0x0 NOT AND DUP2 MSTORE PUSH1 0x20 ADD DUP5 PUSH1 0xFF AND PUSH1 0xFF AND DUP2 MSTORE PUSH1 0x20 ADD DUP4 PUSH1 0x0 NOT AND PUSH1 0x0 NOT AND DUP2 MSTORE PUSH1 0x20 ADD DUP3 PUSH1 0x0 NOT AND PUSH1 0x0 NOT AND DUP2 MSTORE PUSH1 0x20 ADD SWAP5 POP POP POP POP POP PUSH1 0x20 PUSH1 0x40 MLOAD PUSH1 0x20 DUP2 SUB SWAP1 DUP1 DUP5 SUB SWAP1 PUSH1 0x0 DUP7 PUSH2 0x61DA GAS SUB CALL ISZERO ISZERO PUSH2 0x12EC JUMPI INVALID JUMPDEST POP POP PUSH1 0x20 PUSH1 0x40 MLOAD SUB MLOAD PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND EQ JUMPDEST ISZERO PUSH2 0x131B JUMPI PUSH1 0x1 SWAP3 POP PUSH2 0x1325 JUMP JUMPDEST PUSH1 0x0 SWAP3 POP PUSH2 0x1325 JUMP JUMPDEST JUMPDEST POP POP SWAP5 SWAP4 POP POP POP POP JUMP JUMPDEST PUSH2 0x1337 PUSH2 0x1597 JUMP JUMPDEST PUSH2 0x133F PUSH2 0x1597 JUMP JUMPDEST PUSH2 0x1347 PUSH2 0x1597 JUMP JUMPDEST PUSH1 0x0 PUSH1 0x0 PUSH2 0x1354 DUP7 PUSH2 0x108C JUMP JUMPDEST SWAP4 POP PUSH1 0x16 PUSH1 0x40 MLOAD DUP1 MSIZE LT PUSH2 0x1365 JUMPI POP MSIZE JUMPDEST SWAP1 DUP1 DUP3 MSTORE DUP1 PUSH1 0x20 MUL PUSH1 0x20 ADD DUP3 ADD PUSH1 0x40 MSTORE JUMPDEST POP SWAP3 POP PUSH1 0x0 SWAP2 POP DUP8 PUSH32 0x100000000000000000000000000000000000000000000000000000000000000 MUL DUP4 DUP4 DUP1 PUSH1 0x1 ADD SWAP5 POP DUP2 MLOAD DUP2 LT ISZERO ISZERO PUSH2 0x13B4 JUMPI INVALID JUMPDEST SWAP1 PUSH1 0x20 ADD ADD SWAP1 PUSH31 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF NOT AND SWAP1 DUP2 PUSH1 0x0 BYTE SWAP1 MSTORE8 POP DUP7 PUSH32 0x100000000000000000000000000000000000000000000000000000000000000 MUL DUP4 DUP4 DUP1 PUSH1 0x1 ADD SWAP5 POP DUP2 MLOAD DUP2 LT ISZERO ISZERO PUSH2 0x141B JUMPI INVALID JUMPDEST SWAP1 PUSH1 0x20 ADD ADD SWAP1 PUSH31 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF NOT AND SWAP1 DUP2 PUSH1 0x0 BYTE SWAP1 MSTORE8 POP PUSH1 0x0 SWAP1 POP PUSH1 0x0 SWAP1 POP JUMPDEST PUSH1 0x14 DUP2 LT ISZERO PUSH2 0x1508 JUMPI DUP4 DUP2 DUP2 MLOAD DUP2 LT ISZERO ISZERO PUSH2 0x146B JUMPI INVALID JUMPDEST SWAP1 PUSH1 0x20 ADD ADD MLOAD PUSH32 0x100000000000000000000000000000000000000000000000000000000000000 SWAP1 DIV PUSH32 0x100000000000000000000000000000000000000000000000000000000000000 MUL DUP4 DUP4 DUP1 PUSH1 0x1 ADD SWAP5 POP DUP2 MLOAD DUP2 LT ISZERO ISZERO PUSH2 0x14CA JUMPI INVALID JUMPDEST SWAP1 PUSH1 0x20 ADD ADD SWAP1 PUSH31 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF NOT AND SWAP1 DUP2 PUSH1 0x0 BYTE SWAP1 MSTORE8 POP JUMPDEST DUP1 DUP1 PUSH1 0x1 ADD SWAP2 POP POP PUSH2 0x1454 JUMP JUMPDEST DUP3 SWAP5 POP JUMPDEST POP POP POP POP SWAP4 SWAP3 POP POP POP JUMP JUMPDEST DUP3 DUP1 SLOAD PUSH1 0x1 DUP2 PUSH1 0x1 AND ISZERO PUSH2 0x100 MUL SUB AND PUSH1 0x2 SWAP1 DIV SWAP1 PUSH1 0x0 MSTORE PUSH1 0x20 PUSH1 0x0 SHA3 SWAP1 PUSH1 0x1F ADD PUSH1 0x20 SWAP1 DIV DUP2 ADD SWAP3 DUP3 PUSH1 0x1F LT PUSH2 0x1558 JUMPI DUP1 MLOAD PUSH1 0xFF NOT AND DUP4 DUP1 ADD OR DUP6 SSTORE PUSH2 0x1586 JUMP JUMPDEST DUP3 DUP1 ADD PUSH1 0x1 ADD DUP6 SSTORE DUP3 ISZERO PUSH2 0x1586 JUMPI SWAP2 DUP3 ADD JUMPDEST DUP3 DUP2 GT ISZERO PUSH2 0x1585 JUMPI DUP3 MLOAD DUP3 SSTORE SWAP2 PUSH1 0x20 ADD SWAP2 SWAP1 PUSH1 0x1 ADD SWAP1 PUSH2 0x156A JUMP JUMPDEST JUMPDEST POP SWAP1 POP PUSH2 0x1593 SWAP2 SWAP1 PUSH2 0x163F JUMP JUMPDEST POP SWAP1 JUMP JUMPDEST PUSH1 0x20 PUSH1 0x40 MLOAD SWAP1 DUP2 ADD PUSH1 0x40 MSTORE DUP1 PUSH1 0x0 DUP2 MSTORE POP SWAP1 JUMP JUMPDEST PUSH1 0x20 PUSH1 0x40 MLOAD SWAP1 DUP2 ADD PUSH1 0x40 MSTORE DUP1 PUSH1 0x0 DUP2 MSTORE POP SWAP1 JUMP JUMPDEST DUP3 DUP1 SLOAD PUSH1 0x1 DUP2 PUSH1 0x1 AND ISZERO PUSH2 0x100 MUL SUB AND PUSH1 0x2 SWAP1 DIV SWAP1 PUSH1 0x0 MSTORE PUSH1 0x20 PUSH1 0x0 SHA3 SWAP1 PUSH1 0x1F ADD PUSH1 0x20 SWAP1 DIV DUP2 ADD SWAP3 DUP3 PUSH1 0x1F LT PUSH2 0x1600 JUMPI DUP1 MLOAD PUSH1 0xFF NOT AND DUP4 DUP1 ADD OR DUP6 SSTORE PUSH2 0x162E JUMP JUMPDEST DUP3 DUP1 ADD PUSH1 0x1 ADD DUP6 SSTORE DUP3 ISZERO PUSH2 0x162E JUMPI SWAP2 DUP3 ADD JUMPDEST DUP3 DUP2 GT ISZERO PUSH2 0x162D JUMPI DUP3 MLOAD DUP3 SSTORE SWAP2 PUSH1 0x20 ADD SWAP2 SWAP1 PUSH1 0x1 ADD SWAP1 PUSH2 0x1612 JUMP JUMPDEST JUMPDEST POP SWAP1 POP PUSH2 0x163B SWAP2 SWAP1 PUSH2 0x163F JUMP JUMPDEST POP SWAP1 JUMP JUMPDEST PUSH2 0x1661 SWAP2 SWAP1 JUMPDEST DUP1 DUP3 GT ISZERO PUSH2 0x165D JUMPI PUSH1 0x0 DUP2 PUSH1 0x0 SWAP1 SSTORE POP PUSH1 0x1 ADD PUSH2 0x1645 JUMP JUMPDEST POP SWAP1 JUMP JUMPDEST SWAP1 JUMP STOP LOG1 PUSH6 0x627A7A723058 SHA3 0x4f DIFFICULTY PUSH13 0xF8A262C91F4504C4CDAF8DC479 0xf 0xbd 0xb2 DUP3 CALL 0xda CALLDATACOPY STOP NUMBER 0xdb CODECOPY CALLDATASIZE 0x3d 0xbd 0x48 PUSH9 0x2900000000000000 ";

// 3)
    params.clear() ;
    resultObject.clear() ;
    resultObject.insert("from", coinbase) ;       // JP qu'au lieu de mettre l'adresse du mineur (coinbase) il vaut mieu mettre celle du createur du contract
    resultObject.insert("data", contractData ) ;
    params.append(resultObject) ;
    // I can use only 10 args ;
    request = QJsonRpcMessage::createRequest("eth_estimateGas", QJsonArray::fromVariantList(params)) ;
    response = client->sendMessageBlocking(request) ;

    if (response.type() == QJsonRpcMessage::Error) {
        qDebug() << response.errorData() ;
        exit (0) ; // todo change it
    }
    contractGasEstimate = response.result().toString();

// 4)
    params.clear() ;
    resultObject.clear();
    resultObject.insert("from", coinbase) ; // JP ça ne doit pas être l'adresse du miner (coinbase) mais plutôt celle du createur du contract
    resultObject.insert("gas",  contractGasEstimate) ;
    resultObject.insert("data", contractData ) ;
    params.append(resultObject) ;
    // I can use only 10 args ;
    request = QJsonRpcMessage::createRequest("eth_sendTransaction", QJsonArray::fromVariantList(params)) ; // Creates new message call transaction or a contract creation, if the data field contains code.
    response = client->sendMessageBlocking(request) ;
    if (response.type() == QJsonRpcMessage::Error) {
        qDebug() << response.errorData() ;
        exit (0) ; // todo change it
    }
    transactionHash = response.result().toString() ;

// 5)
    params.clear();
    params.append(transactionHash);
    // I can use only 10 args ;
    request = QJsonRpcMessage::createRequest("eth_getTransactionReceipt", QJsonArray::fromVariantList(params)) ;
    response = client->sendMessageBlocking(request) ;
    if (response.type() == QJsonRpcMessage::Error) {
        qDebug() << response.errorData() ;
        exit (0) ; // todo change it
    }
    resultObject.clear() ;
    resultObject = (QVariantMap) response.result().toObject().toVariantMap() ;
    contractAddress = resultObject.take("contractAddress").toString() ;

#if 0
    // 0)
    request  = QJsonRpcMessage::createRequest("eth_accounts") ;
    response = client->sendMessageBlocking(request) ;
    if (response.type() == QJsonRpcMessage::Error) {
        qDebug() << response.errorData() ;
        exit (0) ; // todo: change it
    }

    QStringList allAccounts = response.result().toVariant().toStringList() ;

    QString     paramsTypes ("address") ;
    QStringList paramsValues ;
    for (int i =0; i < allAccounts.length(); i++) {
        paramsValues.append (EncodeAddress(allAccounts.at(i))) ;
        QString v = CallFunction(coinbase,
                                 contractAddress,
                                 EncodeFunction(EncodeFunctionSelector("registerAddress(address)"),
                                                paramsTypes,
                                                paramsValues),
                                 "eth_sendTransaction"
                                 ) ;
        if (v == "0x") {
            qDebug() << "Error:Blockchain::Blockchain, registerAddress transaction failed" ;
            return ;
        }
        paramsValues.clear() ;
    }
#endif
}



Blockchain::~Blockchain ()
{

}

QString Blockchain::getCoinbaseFromTheBlockChain ()
{
    QJsonRpcMessage request  = QJsonRpcMessage::createRequest("eth_coinbase") ;
    QJsonRpcMessage response = client->sendMessageBlocking(request) ;
    if (response.type() == QJsonRpcMessage::Error) {
        qDebug() << response.errorData() ;
        exit(0); // todo: change it
    }

    return response.result().toString() ;
}

#if 0
QString Blockchain::getCoinbase()
{
    return coinbase ;
}

QString Blockchain::getContractData ()
{
    return contractData ;
}

QString Blockchain::getContractGasEstimate ()
{
    return contractGasEstimate ;
}

QString Blockchain::getTransactionHash ()
{
    return transactionHash ;
}

QString Blockchain::getTransactionReturnedValue ()
{
    return transactionReturnedValue ;
}
#endif // #if 0
QString Blockchain::getContractAddress ()
{
    return contractAddress ;
}

#if 0
QStringList Blockchain::getAvailableAccounts ()
{
    QString     paramsTypes = "" ;
    QStringList paramsValues ;
    QString     externalAddress ;

    externalAddress = (getMyExternalAddress().isEmpty()) ? getCoinbase():getMyExternalAddress() ;

    return DecodeAddressArray(CallFunction(externalAddress,
                                           contractAddress,
                                           EncodeFunction(EncodeFunctionSelector("GetAvailableAccounts()"),
                                                          paramsTypes,
                                                          paramsValues),
                                           "eth_call"
                                           )
                              ) ;
}


QStringList Blockchain::getUsedAccounts ()
{    
    QString     paramsTypes = "" ;
    QStringList paramsValues ;
    QString     externalAddr = getMyExternalAddress() ;
    if(externalAddr.isEmpty()) {
        qDebug() << "Error:Blockchain::getUsedAccounts, you don't have the right to do this operation (the external address can not be found)" ;
        return paramsValues ; // empty
    }
    return DecodeAddressArray(CallFunction(externalAddr,
                                           contractAddress,
                                           EncodeFunction(EncodeFunctionSelector("GetUsedAccounts()"),
                                                          paramsTypes,
                                                          paramsValues),
                                           "eth_call"
                                           )
                              ) ;
}


QString Blockchain::getMyExternalAddress ()
{
    return myExternalAddress ;
}

void Blockchain::setMyExternalAddress (const QString& _myExternalAddress)
{
    myExternalAddress = _myExternalAddress ;
}


QString Blockchain::TakeAddress ()
{
    QString     paramsTypes = "" ;
    QStringList paramsValues ;
    QString     v = "" ;

    if (!getMyExternalAddress().isEmpty()) {
        qDebug() << "Error:Blockchain::TakeAddress, you already have an external address" ;
        goto error ;
    }

    paramsTypes = "" ;
    v = DecodeAddress(CallFunction(getCoinbase(),
                                   contractAddress,
                                   EncodeFunction(EncodeFunctionSelector("GetMinterAddress()"),
                                                  paramsTypes,
                                                  paramsValues),
                                   "eth_call"
                                   )
                      ) ;

    if (v.length() != _AddrTypeLen + 2) {
        qDebug() << "Error:Blockchain::TakeAddress, TakeAddress transaction failed" ;
        goto error ;
    }

    paramsValues.clear() ;
error:
    return v ;
}
#endif

#if 0
QString Blockchain::CallFunction (const QString &from,
                                  const QString& to,
                                  const QString& data,
                                  const QString& eth_methodName)
{

    QVariantList    params       ;
    QVariantMap     resultObject ;
    QJsonRpcMessage request      ;
    QJsonRpcMessage response     ;

    resultObject.insert("from", from) ;
    resultObject.insert("to",   to  ) ;
    resultObject.insert("data", data) ;

    params.append(resultObject) ;
        // I can use only 10 args ;
    request  = QJsonRpcMessage::createRequest(eth_methodName, QJsonArray::fromVariantList(params)) ; // Executes a new message call immediately without creating a transaction on the block chain
    response = client->sendMessageBlocking(request) ;
    if (response.type() == QJsonRpcMessage::Error) {
        qDebug() << "Error:Blockchain::CallFunction," << response.errorData() ;
        // exit (0) ; // todo change it
    }

    return response.result().toString() ;
}
#endif // #if 0
QString Blockchain::FileToString (const QString& fileName)
{
    QString contractDef = "" ;
    QFile file(fileName) ;
    if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) {
        qDebug() << "Error : file opening" ;
        return contractDef ;
    }
    while (!file.atEnd())
        contractDef += file.readLine();

    return  contractDef ;
}

#if 0
QString Blockchain::EncodeFunctionSelector(const QString& functionSelector)
{

    QByteArray data ;
    data.append(functionSelector) ; // using this append the Unicode functionName is converted into 8-bit characters using QString::toAscii()
    QByteArray md = QCryptographicHash::hash(data, QCryptographicHash::Sha3_256) ;
    QString first4bytes(md.toHex()) ;

    return first4bytes.left(8) ;
}


bool Blockchain::IsDynamicType(const QString& type) {
    if (type.at(type.length()-1) == ']')
        return true ;
    if      (type == "string") return true ;
    else if (type == "bytes" ) return true ;

    return false ;
}


QString Blockchain::EncodeFunction(const QString& functionSelector, const QString& paramsType, QStringList paramsValues)
{
    QString     value   = ""  ;
    int         dP      = 0   ;

    if (paramsType == "") {
        value = "0x" + functionSelector ;
        QString padding ;
        padding.fill('0', _32Bytes) ;

        return value + padding ;
    }

    QStringList paramsTypes  = paramsType.split(',') ;

    QList <int> dataPosList ; // for the dynamic types

    if (paramsTypes.length() != paramsValues.length()) {
        qDebug () << "Error: ExecuteFunction, paramsTypes.length()" << paramsTypes.length() << "!= paramsValues.length()" << paramsValues.length() ;
        exit (0) ; // todo change it by another one
    }

    value = "0x" + functionSelector ;

    for (int i = 0; i < paramsTypes.length(); i++) {
        if (IsDynamicType(paramsTypes.at(i))) {
            dP += 32 * paramsTypes.length() ;

            for (int j = 0; j < i; j++) {
                if (IsDynamicType(paramsTypes.at(j))) {
                    int dynamicLen = DecodeUint64(paramsValues.at(j).left(_32Bytes)) ;
                    dP += 32 + dynamicLen + (32 - (dynamicLen % 32)) ; // 32 for the dynamicTypeLen of prec dynamicType + ...
                }
            }
            dataPosList.append(dP) ;
            dP = 0 ;
        }
    }

    dP = 0 ;

    for (int i = 0; i < paramsTypes.length(); i++) {
        if (IsDynamicType(paramsTypes.at(i))) {
            value += EncodeUint64(dataPosList.at(dP)) ;
            dP ++ ;
        } else {
            value += paramsValues.at(i) ;
        }
    }

    for (int i = 0; i < paramsTypes.length(); i++) {
        if (IsDynamicType(paramsTypes.at(i)))
            value += paramsValues.at(i);
    }

    return value ;
}



/*We distinguish static and dynamic types.
  Static types are encoded in-place and dynamic types are encoded at a separately allocated location after the current block*/

/* Static types (the length is a multiple of 32 bytes):*/
/*X represent a value*/


QString Blockchain::EncodeUint64(u_int64_t value)
{
/*uint<M>: enc(X) is the big-endian encoding of X, padded on the higher-order (left) side with zero-bytes such that the length is a multiple of 32 bytes*/
    QString v ;
    v = QString::number(value, 16) ; // we should convert the DEC to HEX
    int paddingLen = _32Bytes - (v.length() % _32Bytes) ;
    QString padding (paddingLen, '0') ;

    return padding + v ;
}

u_int64_t Blockchain::DecodeUint64(const QString& value)
{
    bool ok;

    quint64 decodedValue = (value).toUInt(&ok, 16) ;
    if (!ok)
        qDebug() << "Error: Blockchain::DecodeUint64, Conversion failed!";

    return (u_int64_t) decodedValue ;
}


QString Blockchain::EncodeUint8(u_int8_t value) // todo test this function
{
/*uint<M>: enc(X) is the big-endian encoding of X, padded on the higher-order (left) side with zero-bytes such that the length is a multiple of 32 bytes*/
    QString v ;
    v = QString::number(value, 16) ; // we should convert the DEC to HEX
    int paddingLen = _32Bytes - (v.length() % _32Bytes) ;
    QString padding (paddingLen, '0') ;

    return padding + v ;
}

u_int8_t Blockchain::DecodeUint8(const QString& value) // todo test this function
{
    bool ok;

    quint8 decodedValue = (value).toUInt(&ok, 16) ;
    if (!ok)
        qDebug() << "Error: Blockchain::DecodeUint8, Conversion failed!";

    return (u_int8_t) decodedValue ;
}





QString Blockchain::EncodeInt64(int64_t value)
{
/*uint<M>: enc(X) is the big-endian encoding of X, padded on the higher-order (left) side with zero-bytes such that the length is a multiple of 32 bytes*/
    QByteArray  buffer ;
    QDataStream stream(&buffer, QIODevice::WriteOnly) ;
    stream << (qint64)value;
    QString v ;
    QChar paddingValue = '0' ;
    if (value < 0) {
        value *= -1 ;
        paddingValue = 'f' ;
    }
    QString v2 ((QString)buffer.toHex()) ;
    int paddingLen = _32Bytes - (v2.length() % _32Bytes) ;
    v.fill(paddingValue, paddingLen) ;

    return v + v2 ;
}

int64_t Blockchain::DecodeInt64(const QString& value)
{
    bool    ok  = true ;
    QString right_16_bytes = (value).right(16) ;
    qint64  decodedValue = right_16_bytes.toULongLong(&ok, 16) ;
    if (!ok)
        qDebug() << "Error, DecodeInt64, Conversion failed!";

    return (int64_t) decodedValue;
}

QString Blockchain::EncodeBoolean(bool value)
{
/*uint<M>: enc(X) is the big-endian encoding of X, padded on the higher-order (left) side with zero-bytes such that the length is a multiple of 32 bytes*/
    if (value == false)
        return "0000000000000000000000000000000000000000000000000000000000000000" ;
    else
        return "0000000000000000000000000000000000000000000000000000000000000001" ;
}

bool Blockchain::DecodeBoolean(const QString& value)
{
    bool    ok = true ;
    quint64 v  = 0 ;

    v = value.toULongLong(&ok, 16) ;
    if (!ok)
        qDebug() << "Error: DecodeChunkString, Conversion failed!";

    return (bool) v ;
}


// Dynamic types:

QString Blockchain::EncodeString(const QString& value)
{
// dynamic sized unicode string assumed to be UTF-8 encoded
// Note that the length used in this subsequent encoding is the number of bytes of the utf-8 encoded string, not its number of characters
// len(a) is the number of bytes in a binary string a. The type of len(a) is assumed to be uint256

    QString v(value.toUtf8().toHex()) ;
    int32_t paddingLen = _32Bytes - (v.length() % _32Bytes) ;
    QString rightPadding ;
    rightPadding.fill('0', paddingLen) ;

    return EncodeUint64(v.length()/2) + v + rightPadding ;     // (v.length()/2) because we talk Bytes
}

QString Blockchain::DecodeString(const QString& value)
{
    u_int64_t dataPos     = 0  ;
    u_int64_t valueLen    = 0  ;
    QString   v           = "" ;
    QString   vRes        = "" ;
    QString   decodedStr  = "" ;
    u_int32_t chunkNumber = 0  ;
    u_int32_t chunkLen    = 0  ;

    dataPos = DecodeUint64(value.left(2 + _32Bytes)) ;  // 0x = 2 characters
    if (dataPos <= 0) {
        qDebug () << "Error: DecodeString, dataPos <= 0 " ;
        goto error ;
    }
    v = value.mid (2 + _32Bytes) ;
    valueLen = DecodeUint64(v.left(_32Bytes)) * 2 ;      // Byte = 2 characters
    if (valueLen <= 0) {
        qDebug () << "Error: DecodeString, valueLen <= 0 " ;
        goto error ;
    }
    vRes = v.mid(dataPos*2, valueLen) ;                   // dataPos*2 -> because we talk bytes // todo to check this info

    // 8 bytes

    chunkNumber += (valueLen / 8) ;
    chunkNumber += (valueLen % 8) ? 1 : 0 ;
    chunkLen    = 0 ;

    for (u_int32_t i = 0; i < chunkNumber; i++) {
        chunkLen   = (valueLen > 8) ? 8 : valueLen ;
        valueLen   -= chunkLen ;
        decodedStr += DecodeChunkString(vRes.mid(i*8, chunkLen)) ;
        chunkLen   = 0 ;
    }

    if (valueLen != chunkLen) {

        qDebug () << "Error: DecodeString, valueLen("<<valueLen<<") != chunkLen("<<chunkLen<<")" ;
        goto error ;
    }

    return decodedStr ;

error :
    return "" ;
}

QString Blockchain::DecodeChunkString(const QString& value)
{
    bool    ok = true ;
    quint64 decodedValue = 0 ;

    decodedValue = value.toULongLong(&ok, 16) ;
    if (!ok)
        qDebug() << "Error: DecodeChunkString, Conversion failed!";

    QByteArray array ;
    array.setNum(decodedValue, 16) ;
    QString decodedStr (QByteArray::fromHex(array)) ;

    return decodedStr ;
}


QString Blockchain::EncodeAddress(const QString& value)
{
// This is just the right representation (we does not require an encode operation)
    QString paddingValue ;
    QString encodedValue = "" ;

    if (value.left(2) == "0x")
        encodedValue = value.mid(2) ;

    if (encodedValue.length() != _AddrTypeLen) {
        qDebug() << "Error:Blockchain::EncodeAddress, the address is not correct (length should be equal to 20 bytes" ;
        encodedValue = "" ;
        goto error ;
    }

    paddingValue.fill('0', _AddrPaddLen) ;
    encodedValue = paddingValue + encodedValue.right(_AddrTypeLen) ;
error:
    return encodedValue ;
}

QString Blockchain::DecodeAddress(const QString& value)
{
// This is just the right representation (we does not require an encode operation)
    return "0x" + value.right(_AddrTypeLen) ;
}

QStringList Blockchain::DecodeAddressArray(const QString& value)
{
// T[] where X has k elements (k is assumed to be of type uint256)
// enc(X) = enc(k) enc([X[1], ..., X[k]])

    QStringList list        ;
    u_int64_t   dataPos   = 0 ;
    u_int64_t   eltNumber = 0 ;
    QString     addr      = "";

    dataPos   = (DecodeUint64(value.left(2 + _32Bytes))*2) + 2 ;      // +2 for "0x", *2 because 1Byte represented by 2Chars
    eltNumber = DecodeUint64(value.mid(dataPos, _32Bytes)) ; // mid(position, bytesNumber)
    dataPos   += _32Bytes ;
    if ((u_int64_t) value.mid(dataPos).length() != (_32Bytes * eltNumber)) {
        qDebug () << "Error:Blockchain::DecodeAddressArray the received adresses length is not correct" ;
        goto error ;
    }

    for (u_int64_t i =0; i < eltNumber; i++) {
        addr = value.mid(dataPos, _32Bytes) ;
        list << DecodeAddress(addr) ;
        dataPos += _32Bytes ;
    }

error:
    return list ;

}


QString Blockchain::EncodeUint8Array (u_int8_t * value, int64_t valueLen)
{

    QString encValue = "" ;

    if (value == NULL) {
        qDebug () << "Error:Blockchain::EncodeStatTab (value == NULL)" ;
        return "" ;
    }

    if (valueLen <= 0) {
        qDebug () << "Error:Blockchain::EncodeStatTab (valueLen <= 0)" ;
        return "" ;
    }

    encValue = EncodeInt64(valueLen) ;

    for (int i =0 ; i < valueLen; i++) {
        encValue += EncodeUint8(value[i]) ;
    }

    return encValue ;
}


/*not implemented*/
int32_t   DecodeUint8Array   (u_int8_t      * decValue,
                              int32_t         decValueLen,
                              const QString&  value)
{
    Q_UNUSED(decValue)    ;
    Q_UNUSED(decValueLen) ;
    Q_UNUSED(value)       ;
    return 0 ;
}
/*end*/

#endif



















